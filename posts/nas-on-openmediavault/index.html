<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="搭建 openmediavault NAS" /><meta property="og:locale" content="en_US" /><meta name="description" content="本文详细记录了在 openmediavault 上搭建私人 NAS 的过程，包括：安装配置 openmediavault、Docker；部署 Transmission BT 工具、Nextcloud 网盘等容器；配置 HTTP/HTTPS 反向代理和 Let’s Encrypt 证书，最终实现个人 NAS 的搭建。" /><meta property="og:description" content="本文详细记录了在 openmediavault 上搭建私人 NAS 的过程，包括：安装配置 openmediavault、Docker；部署 Transmission BT 工具、Nextcloud 网盘等容器；配置 HTTP/HTTPS 反向代理和 Let’s Encrypt 证书，最终实现个人 NAS 的搭建。" /><link rel="canonical" href="https://linhongbo.com/posts/nas-on-openmediavault/" /><meta property="og:url" content="https://linhongbo.com/posts/nas-on-openmediavault/" /><meta property="og:site_name" content="Hongbo Lin" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-27T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="搭建 openmediavault NAS" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"本文详细记录了在 openmediavault 上搭建私人 NAS 的过程，包括：安装配置 openmediavault、Docker；部署 Transmission BT 工具、Nextcloud 网盘等容器；配置 HTTP/HTTPS 反向代理和 Let’s Encrypt 证书，最终实现个人 NAS 的搭建。","url":"https://linhongbo.com/posts/nas-on-openmediavault/","headline":"搭建 openmediavault NAS","@type":"BlogPosting","dateModified":"2020-04-28T22:53:42+08:00","datePublished":"2020-02-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://linhongbo.com/posts/nas-on-openmediavault/"},"@context":"https://schema.org"}</script><title>搭建 openmediavault NAS | Hongbo Lin</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hongbo Lin"><meta name="application-name" content="Hongbo Lin"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-118658920-3"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-118658920-3'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hongbo Lin</a></div><div class="site-subtitle font-italic">A technology-focused blogger.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/alhongb" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>搭建 openmediavault NAS</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>搭建 openmediavault NAS</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hongbo Lin </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Feb 27, 2020, 12:00 AM +0800" prep="on" > Feb 27, 2020 <i class="unloaded">2020-02-27T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 3, 2021, 11:54 AM +0800" prefix="Updated " > Apr 3 <i class="unloaded">2021-04-03T11:54:33+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6484 words">36 min</span></div></div><div class="post-content"><p>本文详细记录了在 openmediavault 上搭建私人 NAS 的过程，包括：安装配置 openmediavault、Docker；部署 Transmission BT 工具、Nextcloud 网盘等容器；配置 HTTP/HTTPS 反向代理和 Let’s Encrypt 证书，最终实现个人 NAS 的搭建。</p><h2 id="为什么选择-openmediavault">为什么选择 openmediavault？</h2><p>简要对比部分主流 NAS 操作系统，博主认为 openmediavault 更优</p><ul><li><p>Synology DSM</p><p>适合无技术背景或希望开箱即用的用户。博主不选择的原因：</p><ol><li>相对臃肿，不够简洁<li>每块磁盘上都会安装操作系统以及后续安装的软件及其数据，导致用户存储和操作系统耦合，频繁的读写影响每块硬盘的休眠。<li>DIY 设备安装运行涉及版权，无法稳定升级版本</ol><li><p>FreeNAS</p><p>对硬件要求比较高，尤其是内存最低要求 8G，其未来的目标用户应该主要是企业，不选。</p><li><p>openmediavault</p><p>基于 Debian Linux，开源免费。openmediavault 的目标就是面向家庭和小型办公环境，是对熟悉 Linux 又追求最小化安装的人的首选。</p></ul><h2 id="硬件选购建议">硬件选购建议</h2><p>博主用过的 DIY NAS 硬件有小马 V5（已退役）和蜗牛星际，这里提一些硬件选购建议，供读者参考：</p><ul><li>专用设备</ul><p>NAS 的核心功能应当是可靠的数据存储，长期稳定运行是一大要素，因此不建议使用虚拟化技术（一设备多用途）、树莓派等非专用设备来构建你的 NAS。</p><ul><li>低功耗</ul><p>低功耗不仅意味着绿色清洁，还带来更好的散热性能，这些都是 NAS 设备长期运行的基础</p><ul><li>盘位至少 3，最优 4</ul><p>个人认为兼顾数据安全和丰富应用的硬盘布置策略是：占用 2 盘位的 <code class="language-plaintext highlighter-rouge">RAID 1</code>（mirror）+ 1 盘位单盘（或 2 盘位 <code class="language-plaintext highlighter-rouge">RAID 0</code>），前者用于存储个人数据或稀缺资源，后者用于 BT、电影分享等数据容易重新下载的场景。因此满足此策略的 4 盘位硬件就足矣，至于超过 4 盘位的，个人觉得不必要。</p><p>另外，所有的 NAS 系统都有物理机裸装和运行在 ESXi 等虚拟化平台上两种区分，但考虑到虚拟机对 S.M.A.R.T、磁盘休眠等需要硬件直通的特性支持不好，而这些功能是 NAS 长期稳定、低功耗运行的核心，因此强烈建议不要使用虚拟化安装 NAS。</p><p>更新：2 盘位实际上也可以采用 rsync 目录同步软件来实现双盘备份，不失为更经济实用的方案。</p><h2 id="安装-openmediavault">安装 openmediavault</h2><p>openmediavault 基于 Debian，因此安装过程与绝大部分 Linux 发行版没什么两样：先在<a href="https://www.openmediavault.org/?page_id=77">官网</a>下载 ISO 文件，解压到 U 做成启动盘，最后引导设备启动到安装程序完成安装。几个注意事项：</p><ul><li>在安装界面执行磁盘重新分区时，可能会报无法安装系统文件的错误，忽略错误重启一次即可<li>网站提供的 ISO 镜像最新版本是 5.0.5，但安装完成后会自动升级到最新版本<li>安装过程确保联网更新，避免网卡驱动安装异常（重启动后无法获取 IP 地址）等问题。更新源选择国内的节点，如清华，否则速度极慢<li>安装过程语言选项可选择英文或中文，影响 Debian 和 openmediavault 的语言。建议选英文，因为 openmediavault 的时区、语言安装完成后很容易通过其界面更改</ul><h2 id="设置共享文件夹">设置共享文件夹</h2><h3 id="创建共享文件夹">创建共享文件夹</h3><p>openmediavault 成功运行后，就可以用其 Web 图形界面组建 RAID 和创建可被外部访问的<code class="language-plaintext highlighter-rouge">共享文件夹</code>了，基本流程是：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>清除磁盘（可选）- 组建 RAID（可选）- 创建文件系统 - 挂载文件系统 - 添加共享文件夹 - 打开文件共享服务（可选）
</pre></table></code></div></div><p>注意：默认的 <code class="language-plaintext highlighter-rouge">admin</code> 管理员用户不能用于访问共享文件夹，需要新建一个普通用户；所有共享文件访问都应当通过 openmediavault <code class="language-plaintext highlighter-rouge">共享文件夹</code>机制：主机外使用各种基于网络的文件共享服务，主机内使用 <code class="language-plaintext highlighter-rouge">/srv/dev-disk-by-label-xxxx/yoursharedfolder</code> 路径来访问共享文件夹（请注意，在最新的 openmediavault 上，<code class="language-plaintext highlighter-rouge">/sharedfolders/</code> 已废止使用）。</p><h3 id="多用户模式可选">多用户模式（可选）</h3><p>如果你的 NAS 是个人专用，不考虑家庭共享，可以忽略本小节。但是如果你的 NAS 要满足一大家庭或为此做打算，可以如下两种模式中选择一种来设计多用户和共享文件夹，使得不同用户的数据互相隔离。</p><h4 id="模式一使用主目录">模式一：使用主目录</h4><ol><li><p>创建用户</p><p>根据实际需求创建，你、你的家人…</p><li><p>开启<code class="language-plaintext highlighter-rouge">使用主目录</code>选项</p><p>前往 <code class="language-plaintext highlighter-rouge">访问权限管理</code> - <code class="language-plaintext highlighter-rouge">用户</code> - <code class="language-plaintext highlighter-rouge">设置</code> 启用主目录功能，让 openmediavault 为每个用户分配专属家目录。这里 home 目录需要绑定到一个共享文件夹，可以事先创建名为 home 的共享文件夹，该目录属主、用户组应为 root:users，其中 user 组仅有 x 权限，其他用户无权限。</p><li><p>使 Samba 访问时只显示该用户的主目录，不显示多余的 <code class="language-plaintext highlighter-rouge">homes</code> 目录</p><p>前往 <code class="language-plaintext highlighter-rouge">服务</code> - <code class="language-plaintext highlighter-rouge">SMB/CIFS</code> - <code class="language-plaintext highlighter-rouge">主目录</code> - 选中 <code class="language-plaintext highlighter-rouge">启用用户主目录</code>，取消选中<code class="language-plaintext highlighter-rouge">设为可浏览</code></p></ol><p>按照上面方法，每个用户都将拥有独立的数据目录，并且不同用户间互相隔离仅对属主开放权限。</p><p>至于整个家庭范围内共享的数据，可以额外按需创建共享目录。例如：创建一个名为“家庭共享”的共享目录，将所有家庭范围分享的数据放置在此目录下：由于 openmediavault 新建用户默认都属于 <code class="language-plaintext highlighter-rouge">user</code> 组，对于这类共享目录，整个家庭都将可以访问。</p><h4 id="模式二为每个用户创建独立的共享文件夹">模式二：为每个用户创建独立的共享文件夹</h4><p>对于每个新建的用户，单独设立一个共享文件夹，并且对每个共享文件夹执行 ACL 设置隔离规则：</p><ul><li>属主修改为该用户<li>用户组修改为该用户对应的专用用户组，而非 users 组（这要求你提前建立好用户组）</ul><p>修改好以后，不同用户间就没有权限访问对方的共享目录了，但是在 Samba 中，无权限者还是会看到这些共享目录，要对无权限者屏蔽这些共享目录，可在 SMB/CIFS 中对这些共享目录设置一条 <code class="language-plaintext highlighter-rouge">extra options</code>，内容为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>access based share enum = yes
</pre></table></code></div></div><p>同时在 Shared Folders - Privileges 选项中显式拒绝其他用户的访问权限。（正如其说明，Privileges 只会影响共享服务的权限配置，而不会反映到文件系统）</p><h2 id="安装-docker-环境">安装 Docker 环境</h2><h3 id="安装-docker">安装 Docker</h3><p>为了运行 Nextcloud（云盘）、Transmission（BT 下载）等软件，需要安装和配置 Docker 运行环境。</p><p>首先按其官网的方法安装三方扩展插件库 <a href="http://omv-extras.org/">omv-extras</a> ：</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>wget <span class="nt">-O</span> - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash
</pre></table></code></div></div><p>安装完毕后，直接在 openmediavault 新增的 <code class="language-plaintext highlighter-rouge">omv-extras</code> 选项中点击按钮安装 Docker 即可</p><h3 id="安装-portainer">安装 Portainer</h3><p>Portainer 是一个轻量级的 Docker 图形化管理工具，可以用来管理宿主机和 Docker Swarm 集群。Portainer 本身也是以容器运行，因此安装过程就是创建和运行一个容器。</p><p>omv-extras 也提供了 Portainer 的安装界面，直接用它来安装即可。</p><p>安装完成后访问 <em>openmediavualt_host_ip</em>:9000 即可访问其 Web 界面，首次登录需要创建一个管理员用户，然后会让你选择要连接的 Docker 环境，这里我们选择 <code class="language-plaintext highlighter-rouge">Local</code>，即此前安装的 Docker。</p><h2 id="部署-nas-常用应用容器">部署 NAS 常用应用容器</h2><h3 id="docker-container-命令基础">docker container 命令基础</h3><ul><li>Docker 默认以 root 运行容器进程，除非 <code class="language-plaintext highlighter-rouge">docker container</code> 命令指定了 <code class="language-plaintext highlighter-rouge">--user</code> 参数<li><code class="language-plaintext highlighter-rouge">docker container run</code> 命令是创建并运行一个容器，<code class="language-plaintext highlighter-rouge">docker container create</code> 则仅创建容器而不运行。要运行已有的容器，使用 <code class="language-plaintext highlighter-rouge">docker container start</code> 命令<li><code class="language-plaintext highlighter-rouge">--rm</code> 参数是容器运行结束后自动删除该容器文件，由于默认情况下 Docker 每次启动容器都会新创建一个对应的容器文件， 对于仅一次性运行容器的场景，<code class="language-plaintext highlighter-rouge">--rm</code> 参数就会很有用<li><code class="language-plaintext highlighter-rouge">-v</code> 参数说明：</ul><p>Docker 支持三种文件系统实现：<code class="language-plaintext highlighter-rouge">volume</code>，<code class="language-plaintext highlighter-rouge">bind mount</code> 和 <code class="language-plaintext highlighter-rouge">tmpfs mount</code>，它们分别用不同的方式将容器内的文件/目录和宿主的文件/目录关联，使容器能够访问宿主的文件系统/内存文件系统。 其中 <code class="language-plaintext highlighter-rouge">volume</code> 是 Docker 自行管理的文件/目录，也是最易使用的：通过 <code class="language-plaintext highlighter-rouge">-v</code> 参数指定一个唯一的 volume name 以及要关联到的容器内文件/目录即可。<code class="language-plaintext highlighter-rouge">volume</code> 由 Docker 管理，使用时可以是已经存在或未存在的任一个，当不存在时 Docker 会负责创建；<code class="language-plaintext highlighter-rouge">bind mount</code> 是将容器内的目录/文件绑定到宿主上的已有的目录或文件，用法是和 <code class="language-plaintext highlighter-rouge">volume</code> 类似，但 <code class="language-plaintext highlighter-rouge">-v</code> 参数指定的一定是宿主机上某个相对路径或绝对路径。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://docs.docker.com/storage/images/types-of-mounts-volume.png" alt="docker volumes" title="三种 Docker 文件系统关系示意图" /></p><ul><li><p><code class="language-plaintext highlighter-rouge">-e</code> 参数，增加一个供容器使用的环境变量</p><li><p><code class="language-plaintext highlighter-rouge">PUID/PGID</code>，是 <a href="https://www.linuxserver.io/">LinuxServer.io</a> 组织提供的镜像特有的实用功能，作为环境变量指定，以指定容器进程运行所用的 UID/GID</p></ul><h3 id="创建容器专用用户可选">创建容器专用用户（可选）</h3><p>出于安全考虑，创建一个专用的低权限用户来运行各项容器，用以实践权限最小化原则。</p><p>首先直接在 openmediavault 界面中创建一个名为 application 的用户（默认的用户组为 users）。</p><p>那么，未后续如何使用这个新用户来应用权限最小化安全实践？概括而言就是两个方面操作：</p><ol><li>将用户 ID 后续作为所有容器的启动参数，使得容器进程以 application 用户身份和和组运行；<li>对于需要限制容器访问的目录，通过 ACL 限制 application 用户对该目录的访问。</ol><blockquote><p>你可能有疑问，如果容器服务以 application 的 UID 和 GID 运行，在共享目录创建的文件属主将是 application，那其他用户能也访问吗的？</p><p>答案是肯定的。这是因为 openmediavault 共享目录的用户组都是 users，并默认有 setgid 标志位，这使得容器服务在其下创建的子目录和文件将都与共享目录一致，即 users 组。</p></blockquote><h3 id="部署-transmission-容器">部署 Transmission 容器</h3><p>Transmission 用来下载 BT（支持磁力链接）非常不错，支持 Web 界面和包含认证的 RPC 控制，我们选择 linuxserver 提供的镜像，<a href="https://hub.docker.com/r/linuxserver/transmission/">Docker Hub - linuxserver/transmission</a></p><p>容器安装是用 Portainer，具体操作步骤是：</p><ol><li><p>进入 <code class="language-plaintext highlighter-rouge">Volumes</code> - <code class="language-plaintext highlighter-rouge">Add volume</code> 页面创建 Transmission 容器配置数据存储专用 <code class="language-plaintext highlighter-rouge">volume</code></p><ul><li>填写 <code class="language-plaintext highlighter-rouge">Name</code>，例如 <code class="language-plaintext highlighter-rouge">transmission_config</code><li>点击 <code class="language-plaintext highlighter-rouge">Create the volume</code> 创建该 <code class="language-plaintext highlighter-rouge">volume</code></ul><li><p>进入 <code class="language-plaintext highlighter-rouge">Containers</code> - <code class="language-plaintext highlighter-rouge">Add container</code> 页面配置容器参数</p><ul><li>填写任意的 <code class="language-plaintext highlighter-rouge">Name</code>，填写 <code class="language-plaintext highlighter-rouge">Image</code> 为 <code class="language-plaintext highlighter-rouge">linuxserver/transmission</code><li><code class="language-plaintext highlighter-rouge">Manual network port publishing</code> 中点击 <code class="language-plaintext highlighter-rouge">publish a new network port</code>，按 linuxserver/transmission 在 Docker Hub 页面的要求依次添加端口映射<li><code class="language-plaintext highlighter-rouge">Volumes</code> - <code class="language-plaintext highlighter-rouge">Volume mapping</code> 选项中将专用于存储配置数据的 <code class="language-plaintext highlighter-rouge">Volume</code> 即 <code class="language-plaintext highlighter-rouge">transmission_config</code>，绑定到 <code class="language-plaintext highlighter-rouge">/config</code> 和 <code class="language-plaintext highlighter-rouge">/watch</code>；<code class="language-plaintext highlighter-rouge">Bind</code> 形式绑定 <code class="language-plaintext highlighter-rouge">/downloads</code> 到你指定的 NAS 共享目录。<li><code class="language-plaintext highlighter-rouge">Env</code> - <code class="language-plaintext highlighter-rouge">Environment variables</code> 中添加 <code class="language-plaintext highlighter-rouge">PUID</code>、<code class="language-plaintext highlighter-rouge">PGID</code> 两个环境变量，如果只想方便可分别填写 <code class="language-plaintext highlighter-rouge">1000</code> 和 <code class="language-plaintext highlighter-rouge">100</code> 即你的 openmediavault 使用用户和 <code class="language-plaintext highlighter-rouge">users</code> 组，如果想最小化运行权限，可填写<a href="#创建容器专用用户可选">创建容器专用用户</a>一节创建的 application 用户的 UID 和 GID，同时将第 1 步绑定 downloads 的共享文件夹目录属主修改为 <code class="language-plaintext highlighter-rouge">application</code>（用户组保持 users 不变）,开放给容器访问。<li><code class="language-plaintext highlighter-rouge">Restart policy</code> 中选择 <code class="language-plaintext highlighter-rouge">Unless stopped</code><li>最后点击 <code class="language-plaintext highlighter-rouge">Deploy the container</code> 完成容器部署</ul></ol><h3 id="部署-nextcloud-容器">部署 Nextcloud 容器</h3><p><em>建议使用 File Browser 替代</em></p><p>Nextcloud 作为云盘软件，实际上主要的文件管理功能完全可以使用 openmediavault 提供的 Samba/NFS 替代，但是如果要在 Internet 上分享文件，后者就十分乏力了。</p><p>我同样选择 linuxserver 提供的镜像，<a href="https://hub.docker.com/r/linuxserver/nextcloud">Docker Hub - linuxserver/nextcloud</a>。之所以不选择官方镜像，是因为其不支持设置容器进程的 UID/GID，无法控制容器进程的读写权限。</p><p>Nextcloud 容器运行起来后，还要编辑一下它的配置文件，将域名修正为你自己的实际域名，我的例子是 <code class="language-plaintext highlighter-rouge">nextcloud.linhongbo.com</code></p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>vim /var/lib/docker/volumes/nextcloud_config/_data/www/nextcloud/config/config.php

&lt;?php
<span class="nv">$CONFIG</span> <span class="o">=</span> array <span class="o">(</span>
  <span class="s1">'memcache.local'</span> <span class="o">=&gt;</span> <span class="s1">'\\OC\\Memcache\\APCu'</span>,
  <span class="s1">'datadirectory'</span> <span class="o">=&gt;</span> <span class="s1">'/data'</span>,
  <span class="s1">'instanceid'</span> <span class="o">=&gt;</span> <span class="s1">'oc2sfcyt03u3'</span>,
  <span class="s1">'passwordsalt'</span> <span class="o">=&gt;</span> <span class="s1">'1234567890abcdefg...'</span>,
  <span class="s1">'secret'</span> <span class="o">=&gt;</span> <span class="s1">'1234567890abcdefg...'</span>,
  <span class="s1">'trusted_domains'</span> <span class="o">=&gt;</span>
  array <span class="o">(</span>
          0 <span class="o">=&gt;</span> <span class="s1">'openmediavault'</span>,
          1 <span class="o">=&gt;</span> <span class="s1">'nextcloud.linhongbo.com'</span>,
  <span class="o">)</span>,
  <span class="s1">'dbtype'</span> <span class="o">=&gt;</span> <span class="s1">'sqlite3'</span>,
  <span class="s1">'version'</span> <span class="o">=&gt;</span> <span class="s1">'18.0.1.3'</span>,
  <span class="s1">'overwrite.cli.url'</span> <span class="o">=&gt;</span> <span class="s1">'https://nextcloud.linhongbo.com:8443'</span>,
  <span class="s1">'installed'</span> <span class="o">=&gt;</span> <span class="nb">true</span>,
<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="部署-file-browser-容器">部署 File Browser 容器</h3><p>相比 Nextcloud，File Browser 更轻量，博主推荐使用 File Browser，轻量、界面简洁。</p><p>File Browser 有两个 docker 镜像可供选择：<a href="https://hub.docker.com/r/filebrowser/filebrowser">官方镜像</a>，<a href="https://hub.docker.com/r/hurlenko/filebrowser">更好用的镜像</a>，推荐使用后者。因为官方镜像无法使用普通用户启动（容器绑定 80 端口需要 root），且配置项也比较奇怪。</p><p>不想使用 root 用户来运行的注意：Portainer 配置容器参数时，可将 <code class="language-plaintext highlighter-rouge">user</code> 参数配置成普通用户的 UID 和 GID，形如：1000:100，同时容器分配、绑定的 volume 目录属主也要相应修改，避免权限问题。假设分配给容器的 volume 名为 <code class="language-plaintext highlighter-rouge">file_browser</code>，则要修改属主为对应普通用户的目录是：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>drwxr-xr-x 3 hongbo users 4096 11月 29 08:16 /var/lib/docker/volumes/file_browser/_data
</pre></table></code></div></div><h3 id="部署-emby-server-容器">部署 Emby Server 容器</h3><p>相比 Plex 博主更喜欢 Emby。镜像地址：<a href="https://hub.docker.com/r/emby/embyserver/">Docker Hub - emby/embyserver</a></p><p>同样的，embyserver 容器的 <code class="language-plaintext highlighter-rouge">UID/GID</code> 环境变量如果只想方便可分别填写 <code class="language-plaintext highlighter-rouge">1000</code> 和 <code class="language-plaintext highlighter-rouge">100</code> 即你的 openmediavault 使用用户和 <code class="language-plaintext highlighter-rouge">users</code> 组，如果想最小化运行权限，可填写<a href="#创建容器专用用户可选">创建容器专用用户</a>一节创建的 application 用户和用户组，同时将第 Emby 的 volume 目录属主修改为 <code class="language-plaintext highlighter-rouge">application</code>（用户组保持 users 不变）,开放给容器访问：</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chown </span>application transmission_volume_directory
</pre></table></code></div></div><h3 id="使用域名访问容器">使用域名访问容器</h3><p>默认情况下，我们会用 <code class="language-plaintext highlighter-rouge">IP:端口</code> 方式访问容器提供的 Web 服务，并且用端口号来区分不同的服务，这在容器数量较多时显得非常不优雅。</p><p>有两种解决方案，分别适用不同场景：</p><ol><li>如果你有公开域名并希望容器能够被公网访问，可以在域名 DNS 服务提供商中配置新的容器服务域名，并解析到可访问容器的公网 IP（这通常需要宽带运营商提供公网 IP，并且你已<a href="https://linhongbo.com/posts/openwrt-cloudflare-ddns/">配置好 DDNS</a>）<li>如果你没有公开域名或仅在局域网访问容器服务，可以配置本地域名。具体方法不一，对于 OpenWrt 来说，以下两种方法均可</ol><ul><li><p>在 Luci Web 界面 <code class="language-plaintext highlighter-rouge">Network - Hostnames</code> 中添加域名和对应的 IP 地址</p><li><p>在 <code class="language-plaintext highlighter-rouge">/etc/hosts</code>，中添加域名和对应的 IP 地址，形如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  192.168.0.2 portainer.linhongbo.com
  ...
</pre></table></code></div></div></ul><h2 id="启用-https">启用 HTTPS</h2><p>出于安全考虑，一些 Web 服务需要启用 HTTPS，尤其是对公网暴露或涉及账户口令的。这里博主采用 Let’s Encrypt 的通配证书方案，并以 openmediavault-webgui 为例启用 HTTPS。</p><h3 id="申请-lets-encrypt-通配证书">申请 Let’s Encrypt 通配证书</h3><p>2018 年 3 月 Let’s Encrypt 终于宣布支持 ACME v2 and Wildcard Certificate，即通配符证书。非常振奋人心，Good Job！申请通配符证书需要在域名的 DNS 上配置 <code class="language-plaintext highlighter-rouge">TXT</code> 记录，我们先尝试手动模式申请通配符证书，然后运行一个对应于域名 DNS 服务商的 Certbot 容器来自动申请</p><ul><li>手动申请</ul><p>安装 Certbot</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>apt <span class="nb">install </span>certbot
</pre></table></code></div></div><p>接着运行如下命令给你的域名申请统配符证书（将命令中的域名替换成你自己的）</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>certbot certonly <span class="nt">--manual</span> <span class="nt">--preferred-challenges</span> dns <span class="nt">--server</span> https://acme-v02.api.letsencrypt.org/directory <span class="nt">--manual-public-ip-logging-ok</span> <span class="nt">-d</span> <span class="s1">'*.linhongbo.com'</span> <span class="nt">-d</span> linhongbo.com
</pre></table></code></div></div><p>Cetbot 会先提示提供邮箱，这里如实填写，以接收证书过期提醒邮件；然后要求配置一个指定值的名为 <code class="language-plaintext highlighter-rouge">_acme-challenge</code> 的 DNS TXT 记录，我们到自己的 DNS 服务商面板上配置即可；最后稍等片刻，先用 <a href="https://dns.google.com">dns.google.com</a> 查询一下 TXT 记录是否生效，确认生效后回车。待 Let’s Encrypt 校验域名所有权后，会签发证书，成功申请的输出如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/linhongbo.com/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/linhongbo.com/privkey.pem
   Your cert will expire on 2018-06-12. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot-auto
   again. To non-interactively renew *all* of your certificates, run
   "certbot-auto renew"
 - If you like Certbot, please consider supporting our work by:
 
 
   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le
</pre></table></code></div></div><p>Cetbot 将证书和私钥归档在 <code class="language-plaintext highlighter-rouge">/etc/letsencrypt/archive/yourdomain.domain/</code> 下，但我们应通过其额外提供的软连接访问，即</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>/etc/letsencrypt/live/linhongbo.com/fullchain.pem
/etc/letsencrypt/live/linhongbo.com/privkey.pem
</pre></table></code></div></div><ul><li>自动申请</ul><p>自动申请能够自动化配置 DNS TXT 记录，这需要 Certbot 安装对应域名服务商的插件，处于方便考虑，直接采用 Docker 容器运行。</p><p>首先，创建一个用于访问 DNS 服务商 API 的接口配置文件，内容根据你实际 DNS 服务商提的而不同，博主例子是 Cloudflare</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>vim cloudflare.ini

<span class="c"># Cloudflare API credentials used by Certbot</span>
dns_cloudflare_email <span class="o">=</span> cloudflare@example.com
dns_cloudflare_api_key <span class="o">=</span> 0123456789abcdef0123456789abcdef01234
</pre></table></code></div></div><p>其中 <code class="language-plaintext highlighter-rouge">dns_cloudflare_email</code> 为 Cloudflare 账号邮箱；<code class="language-plaintext highlighter-rouge">dns_cloudflare_api_key</code> 千万 <a href="https://dash.cloudflare.com/profile/api-tokens">Cloudflare - API Keys - Global API Key</a> 获取</p><p>接着在 Docker Hub 上查找到对应的 <a href="https://hub.docker.com/u/certbot/">Certbot 镜像</a>，我的例子是 certbot/dns-cloudflare，然后运行如下命令申请证书</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> certbot <span class="se">\</span>
            <span class="nt">-v</span> <span class="s2">"/etc/letsencrypt:/etc/letsencrypt"</span> <span class="se">\</span>
            <span class="nt">-v</span> <span class="s2">"/var/lib/letsencrypt:/var/lib/letsencrypt"</span> <span class="se">\</span>
            <span class="nt">-v</span> <span class="s2">"/root/cloudflare.ini:/cloudflare.ini"</span> <span class="se">\</span>
            certbot/dns-cloudflare certonly <span class="nt">--preferred-challenges</span> dns <span class="nt">--dns-cloudflare</span> <span class="nt">--dns-cloudflare-credentials</span> /cloudflare.ini  <span class="nt">-d</span> <span class="k">*</span>.linhongbo.com <span class="nt">-d</span> linhongbo.com <span class="nt">--server</span> https://acme-v02.api.letsencrypt.org/directory
</pre></table></code></div></div><p>其中 <code class="language-plaintext highlighter-rouge">/root/cloudflare.ini</code> 替换为你自己的文件路径。</p><p>Letsencrypt 证书三个月过期，到期 renew 时再执行上述 Docker 命令即可，此时会提示证书可以 renew。</p><h3 id="为-openmediavault-webgui-启用-https">为 openmediavault-webgui 启用 HTTPS</h3><p>openmediavault 界面提供了 HTTPS 配置功能，但密钥管理功能很不友好，建议直接采取以下手动方法来启用 HTTPS</p><p>创建额外的 openmediavault-webgui 配置文件：</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">cd</span> /etc/nginx/openmediavault-webgui.d
<span class="nb">touch </span>custom.conf
vim custom.conf
</pre></table></code></div></div><p>添加如下配置：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>listen [::]:443 default_server ipv6only=off;
ssl_certificate /etc/letsencrypt/live/linhongbo.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/linhongbo.com/privkey.pem;
</pre></table></code></div></div><p>最后使用 nginx -s reload 加载配置即可</p><h2 id="nginx-反向代理">Nginx 反向代理</h2><p>反向代理可以使局域网内的 Web 服务直接通过标准的 HTTP/HTTPS 域名、端口（80/443）访问。openmediavault 预置安装了 Nginx（被其管理界面使用），我们直接复用这个 Nginx 为本机上的各个容器或其他主机上的服务提供反向代理。</p><p>有两种反向代理配置模式：一种是每个为目标 Web 服务创建一个代理 Virtual Host，另一种则是直接在主 Host 下分配 <code class="language-plaintext highlighter-rouge">location</code> 目录。前者需要为每个代理 Host 增加 DNS 记录，配置和维护起来稍显麻烦，好处是对浏览器比较友好；后者则只需维护一个主 Host 的 DNS，配置起来也相对简洁容易。</p><h3 id="location-目录反向代理">location 目录反向代理</h3><p>创建并编辑 <code class="language-plaintext highlighter-rouge">/etc/nginx/openmediavault-webgui.d/proxy.conf</code>，按如下可用的 filebrowser、Portainer、Emby、transmission 的反向代理配置：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre>location /filebrowser {
    # prevents 502 bad gateway error
    proxy_buffers 8 32k;
    proxy_buffer_size 64k;

    client_max_body_size 75M;

    # redirect all HTTP traffic to localhost:9001;
    proxy_pass http://localhost:9001;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #proxy_set_header X-NginX-Proxy true;

    # enables WS support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 999999999;
}

location /portainer/ {
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header Connection "";
    proxy_pass http://localhost:9000/;
}
location /portainer/api/websocket/ {
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_http_version 1.1;
    proxy_pass http://localhost:9000/api/websocket/;
}

location /emby/ {
    # prevents 502 bad gateway error
    proxy_buffers 8 32k;
    proxy_buffer_size 64k;

    client_max_body_size 75M;

    # redirect all HTTP traffic to localhost:9001;
    proxy_pass http://localhost:9003/;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #proxy_set_header X-NginX-Proxy true;

    # enables WS support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 999999999;
}

location /transmission {
    # prevents 502 bad gateway error
    proxy_buffers 8 32k;
    proxy_buffer_size 64k;

    client_max_body_size 75M;

    # redirect all HTTP traffic to localhost:9002;
    proxy_pass http://localhost:9002;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #proxy_set_header X-NginX-Proxy true;

    # enables WS support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 999999999;
}
</pre></table></code></div></div><h3 id="virtual-host-反向代理">Virtual Host 反向代理</h3><p>以配置 Nextcloud 为例，首先创建其 Virtul Host 配置文件：</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>vim /etc/nginx/sites-available/nextcloud

server <span class="o">{</span>
    <span class="c">#常规 HTTP/HTTPS 端口，用于局域网访问。遵循一端口全局仅配置一次 ipv6=off 规则，例如 openmediavault 的 80 或 443 端口的配置语句已经包含了 `ipv6only=off`，下面就要去除掉对应的 `ipv6only=off`</span>
    listen <span class="o">[</span>::]:80 <span class="nv">ipv6only</span><span class="o">=</span>off<span class="p">;</span>
    listen <span class="o">[</span>::]:443 <span class="nv">ipv6only</span><span class="o">=</span>off ssl http2<span class="p">;</span>
    
    <span class="c">#出于安全考虑，如果该服务需要被公网访问，额外监听一个端口作为转发专用端口，以对接路由器 WAN 侧</span>
    <span class="c">#listen [::]:8443 ipv6only=off ssl http2;</span>

    server_name nextcloud.linhongbo.com<span class="p">;</span>
    
    ssl_certificate /etc/letsencrypt/live/linhongbo.com/fullchain.pem<span class="p">;</span>
    ssl_certificate_key /etc/letsencrypt/live/linhongbo.com/privkey.pem<span class="p">;</span>
    ssl_verify_client off<span class="p">;</span>
    proxy_ssl_verify off<span class="p">;</span> 
    location / <span class="o">{</span>
        proxy_pass  http://localhost:9096<span class="p">;</span>
        proxy_set_header Host <span class="nv">$http_host</span><span class="p">;</span>
        proxy_set_header X-Real-IP <span class="nv">$remote_addr</span><span class="p">;</span>
        proxy_set_header X-Forwarded-For <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
        proxy_set_header X-Forwarded-Proto <span class="nv">$scheme</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>其中，</p><ul><li><code class="language-plaintext highlighter-rouge">ipv6only=off</code> 表示监听的 ipv6 socket 既可以处理 ipv6 也可以处理 ipv4 数据包（这是 Linux 的一个新特性，新版 Ningx 默认为 <code class="language-plaintext highlighter-rouge">on</code>，即在该端口上仅监听 ipv6 数据包）。这个选项可以使配置更简洁，而无需（且不能）额外配置 ipv4 监听语句，形如 <code class="language-plaintext highlighter-rouge">listen 0.0.0.0:80</code>。但要注意如果有多个 <code class="language-plaintext highlighter-rouge">server</code> 块监听同一端口，这种写法要求该端口的 <code class="language-plaintext highlighter-rouge">ipv6only=off</code> 选项<strong>必须</strong>且<strong>只能</strong>出现一次，否则会导致 <code class="language-plaintext highlighter-rouge">Address already in use</code> 错误（两个端口同时处理 ipv4 请求）或无法处理 ipv4 请求。也就是说由于 openmediavault WEB 界面自身监听的 80 端口和 443 端口（如果启用 HTTPS）在其配置文件中已经配置了 <code class="language-plaintext highlighter-rouge">ipv6only=off</code>，遵循只能出现一次的规则，你额外的 Virtual Host 配置中 80 和 443 端口就不需且不能再配置 <code class="language-plaintext highlighter-rouge">ipv6only=off</code> 了。<li><code class="language-plaintext highlighter-rouge">server_name</code> 指定服务对应的域名<li><code class="language-plaintext highlighter-rouge">ssl_certificate</code> 和 <code class="language-plaintext highlighter-rouge">ssl_certificate_key</code> 分别填写先前申请的 Let’s Encrypt 证书、私钥文件；<li><code class="language-plaintext highlighter-rouge">proxy_ssl_verify off</code> 表示关闭 Nginx 到上游服务器（Nextcloud 容器服务）的 SSL/TLS 校验，由于我是反向代理到 Nextcloud 容器的 HTTPS 服务，因此该选项必须。<li><code class="language-plaintext highlighter-rouge">proxy_set_header Host $http_host</code> 表示反向代理时替换掉 HTTP Header 中的 host 参数，这对 Nextcloud 是必要的，否则会报域名不被信任的错误；<li><code class="language-plaintext highlighter-rouge">proxy_pass https://localhost:9443</code> 设置被代理容器监听的本地回环地址和端口号；<li><code class="language-plaintext highlighter-rouge">proxy_set_header X-Real-IP $remote_addr</code> 和 <code class="language-plaintext highlighter-rouge">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for</code> 指示 Nginx 发起反向代理请求时增加原始 IP 字段到 HTTP Header，这对一些依赖源 IP 来认证客户端的 Web 服务非常重要，例如 Emby，由于反向代理时 Nginx 位于 localhost 或局域网，如不设置此参数 Emby 将认为请求是来源于局域网，从而造成安全功能误判。因此建议所有被代理服务配置上此选项。<li><code class="language-plaintext highlighter-rouge">http2</code> 支持 http2，加速网站加载。注意仅 HTTPS 支持此特性。</ul><p>将上述配置文件拷贝到 <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-enabled</code> 目录使能起来，这里应用软链接</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/nextcloud /etc/nginx/sites-enabled/nextcloud
</pre></table></code></div></div><p>命令 Nginx 重新加载配置</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>nginx <span class="nt">-s</span> reload
</pre></table></code></div></div><h2 id="端口转发公网访问">端口转发（公网访问）</h2><p>最后，为了能在公网访问 openmediavault 上的 WEB 服务，需要在路由器的防火墙规则中增加一条 WAN:8443 -&gt; openmediavault:8443 的 tcp 端口转发规则，这里 WAN 域端口选择 <code class="language-plaintext highlighter-rouge">8443</code> 而非 HTTPS 默认的 443 端口是因为该端口已运营商防火墙封锁了。此外由于 80 端口亦被封锁，博主不再配置 HTTP（80）端口的转发规则，因为不会带来任何访问上的裨益（网址仍要指定端口才能访问）。</p><h2 id="vpn">VPN</h2><p>VPN 可以在公网和家庭局域网之间创建隧道，从而容易访问内网的各项服务。很多路由器都提供了这项功能。如果你想使用 Shadowsocks 来替代 VPN，可以参考博主的这篇文章：<a href="https://linhongbo.com/posts/shadowsocks-server-on-openwrt/">OpenWrt 安装 Shadowsocks Server</a></p><h2 id="常见问题">常见问题</h2><h3 id="反向代理性能差">反向代理性能差</h3><p>默认配置，Nginx 会将后端请求缓存起来（如果缓存空间不够还会写入本地文件）再发送给客户端，这样就会对 Emby 等大流量数据流场景形成性能瓶颈，导致卡顿现象。</p><p>解决办法是在对应域名的 <code class="language-plaintext highlighter-rouge">server</code> 块中加入如下一行配置（建议在 <code class="language-plaintext highlighter-rouge">nginx.conf</code> - <code class="language-plaintext highlighter-rouge">http</code> 中全局配置）</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>proxy_buffering off;
</pre></table></code></div></div><p>这样，Nginx 获取到后端响应就会立即传送给客户端。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tutorial/'>Tutorial</a>, <a href='/categories/nas/'>NAS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/openmediavault/" class="post-tag no-text-decoration" >openmediavault</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=搭建 openmediavault NAS - Hongbo Lin&url=https://linhongbo.com/posts/nas-on-openmediavault/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=搭建 openmediavault NAS - Hongbo Lin&u=https://linhongbo.com/posts/nas-on-openmediavault/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=搭建 openmediavault NAS - Hongbo Lin&url=https://linhongbo.com/posts/nas-on-openmediavault/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/shadowsocks-server-on-openwrt/">OpenWrt 安装 Shadowsocks Server</a><li><a href="/posts/shadowsocks-on-openwrt/">OpenWrt Shadowsocks 安装&配置指南</a><li><a href="/posts/nas-on-openmediavault/">搭建 openmediavault NAS</a><li><a href="/posts/openwrt-cloudflare-ddns/">OpenWrt Cloudflare DDNS</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/dexguard/">DexGuard</a> <a class="post-tag" href="/tags/nas/">NAS</a> <a class="post-tag" href="/tags/apache/">Apache</a> <a class="post-tag" href="/tags/chromium/">Chromium</a> <a class="post-tag" href="/tags/compiler/">compiler</a> <a class="post-tag" href="/tags/ddns/">DDNS</a> <a class="post-tag" href="/tags/esxi/">ESXi</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/install-nextcloud-and-aria2/"><div class="card-body"> <span class="timeago small" > May 4, 2018 <i class="unloaded">2018-05-04T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>大容量 VPS 搭建 Nextcloud 个人云盘 + aria2 在线下载</h3><div class="text-muted small"><p> 简介 Nextcloud 是一套用于创建网络硬盘的客户端－服务器开源软件，使用与 Dropbox 相近。每个人都可以在私人服务器上安装并运行它。 aria2 是一款流行的开源下载工具，支持多种协议，包括磁力链接和 BT。 Resillio Sync，你可能已经听说过这款神奇的文件同步软件，在本文中会作为 aria2 BT下载功能的补充。 这篇教程所使用的环境是 CentOS 7 LA...</p></div></div></a></div><div class="card"> <a href="/posts/nas-usual-configuration-records/"><div class="card-body"> <span class="timeago small" > Dec 2, 2018 <i class="unloaded">2018-12-02T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>NAS 相关问题记录</h3><div class="text-muted small"><p> 一些常用命令 查找最新修改的文件 (5 分钟内) find ./ -mmin -5 -type f 查看文件夹的大小 du -h --max-depth=0 /foo/bar 将频繁写入的日志文件挂载到 /dev/null #!/bin/sh #mount -o bind /dev/null /var/log/scemd.log mount -o bind /...</p></div></div></a></div><div class="card"> <a href="/posts/shadowsocks-on-openwrt-with-gfwlist/"><div class="card-body"> <span class="timeago small" > Jun 21, 2019 <i class="unloaded">2019-06-21T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenWrt Shadowsocks 使用 GFWList 路由规则</h3><div class="text-muted small"><p> 介绍 在 《OpenWrt Shadowsocks 安装&amp;配置指南》一文中博主详细介绍了使用 CHNRoutes 规则翻墙方案，本文进一步说明如何在其基础上切换为 GFWList 规则，即仅在 GFWList 中流量的走 Shadowsocks 代理。方案的基本思路是基于 GFWList IP 地址列表构建 iptables (防火墙) 规则，将目标 IP 的流量转发至 Shado...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/introduction-to-compiler/" class="btn btn-outline-primary" prompt="Older"><p>编译器介绍</p></a> <a href="/posts/openwrt-cloudflare-ddns/" class="btn btn-outline-primary" prompt="Newer"><p>OpenWrt Cloudflare DDNS</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">Hongbo Lin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/dexguard/">DexGuard</a> <a class="post-tag" href="/tags/nas/">NAS</a> <a class="post-tag" href="/tags/apache/">Apache</a> <a class="post-tag" href="/tags/chromium/">Chromium</a> <a class="post-tag" href="/tags/compiler/">compiler</a> <a class="post-tag" href="/tags/ddns/">DDNS</a> <a class="post-tag" href="/tags/esxi/">ESXi</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://linhongbo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
